
// Generated by dojo-bindgen on Sat, 5 Oct 2024 22:46:05 +0000. Do not modify this file manually.
// Import the necessary types from the recs SDK
// generate again with `sozo build --typescript` 
import { Account, byteArray } from "starknet";
import { DojoProvider } from "@dojoengine/core";
import * as models from "./models.gen";

export type IWorld = Awaited<ReturnType<typeof setupWorld>>;

export async function setupWorld(provider: DojoProvider) {
    // System definitions for `memeart-MemeArt` contract
    function MemeArt() {
        const contract_name = "MemeArt";

        
        // Call the `world` system with the specified Account and calldata
        const world = async (props: { account: Account }) => {
            try {
                return await provider.execute(
                    props.account,
                    {
                        contractName: contract_name,
                        entrypoint: "world",
                        calldata: [],
                    },
                    "memeart"
                );
            } catch (error) {
                console.error("Error executing spawn:", error);
                throw error;
            }
        };
            

    
        // Call the `createDrawing` system with the specified Account and calldata
        const createDrawing = async (props: { account: Account, name: bigint, symbol: bigint, rdmSalt: bigint }) => {
            try {
                return await provider.execute(
                    props.account,
                    {
                        contractName: contract_name,
                        entrypoint: "createDrawing",
                        calldata: [props.name,
                props.symbol,
                props.rdmSalt],
                    },
                    "memeart"
                );
            } catch (error) {
                console.error("Error executing spawn:", error);
                throw error;
            }
        };
            

    
        // Call the `colorPixels` system with the specified Account and calldata
        const colorPixels = async (props: { account: Account, drawingId: number, x: RecsType.NumberArray, y: RecsType.NumberArray, r: RecsType.NumberArray, g: RecsType.NumberArray, b: RecsType.NumberArray }) => {
            try {
                return await provider.execute(
                    props.account,
                    {
                        contractName: contract_name,
                        entrypoint: "colorPixels",
                        calldata: [props.drawingId,
                ...props.x,
                ...props.y,
                ...props.r,
                ...props.g,
                ...props.b],
                    },
                    "memeart"
                );
            } catch (error) {
                console.error("Error executing spawn:", error);
                throw error;
            }
        };
            

    
        // Call the `setOwner` system with the specified Account and calldata
        const setOwner = async (props: { account: Account, owner: bigint }) => {
            try {
                return await provider.execute(
                    props.account,
                    {
                        contractName: contract_name,
                        entrypoint: "setOwner",
                        calldata: [props.owner],
                    },
                    "memeart"
                );
            } catch (error) {
                console.error("Error executing spawn:", error);
                throw error;
            }
        };
            

    
        // Call the `setPixelsRowCount` system with the specified Account and calldata
        const setPixelsRowCount = async (props: { account: Account, pixelsRowCount: number }) => {
            try {
                return await provider.execute(
                    props.account,
                    {
                        contractName: contract_name,
                        entrypoint: "setPixelsRowCount",
                        calldata: [props.pixelsRowCount],
                    },
                    "memeart"
                );
            } catch (error) {
                console.error("Error executing spawn:", error);
                throw error;
            }
        };
            

    
        // Call the `setPixelsColumnCount` system with the specified Account and calldata
        const setPixelsColumnCount = async (props: { account: Account, pixelsColumnCount: number }) => {
            try {
                return await provider.execute(
                    props.account,
                    {
                        contractName: contract_name,
                        entrypoint: "setPixelsColumnCount",
                        calldata: [props.pixelsColumnCount],
                    },
                    "memeart"
                );
            } catch (error) {
                console.error("Error executing spawn:", error);
                throw error;
            }
        };
            

    
        // Call the `setRaiseTarget` system with the specified Account and calldata
        const setRaiseTarget = async (props: { account: Account, raiseTarget: models.U256 }) => {
            try {
                return await provider.execute(
                    props.account,
                    {
                        contractName: contract_name,
                        entrypoint: "setRaiseTarget",
                        calldata: [props.raiseTarget.low,
                    props.raiseTarget.high],
                    },
                    "memeart"
                );
            } catch (error) {
                console.error("Error executing spawn:", error);
                throw error;
            }
        };
            

    
        // Call the `setQuoteCurrency` system with the specified Account and calldata
        const setQuoteCurrency = async (props: { account: Account, quoteCurrency: bigint }) => {
            try {
                return await provider.execute(
                    props.account,
                    {
                        contractName: contract_name,
                        entrypoint: "setQuoteCurrency",
                        calldata: [props.quoteCurrency],
                    },
                    "memeart"
                );
            } catch (error) {
                console.error("Error executing spawn:", error);
                throw error;
            }
        };
            

    
        // Call the `setTokenHash` system with the specified Account and calldata
        const setTokenHash = async (props: { account: Account, tokenHash: bigint }) => {
            try {
                return await provider.execute(
                    props.account,
                    {
                        contractName: contract_name,
                        entrypoint: "setTokenHash",
                        calldata: [props.tokenHash],
                    },
                    "memeart"
                );
            } catch (error) {
                console.error("Error executing spawn:", error);
                throw error;
            }
        };
            

    
        // Call the `setTokenTotalSupply` system with the specified Account and calldata
        const setTokenTotalSupply = async (props: { account: Account, tokenTotalSupply: models.U256 }) => {
            try {
                return await provider.execute(
                    props.account,
                    {
                        contractName: contract_name,
                        entrypoint: "setTokenTotalSupply",
                        calldata: [props.tokenTotalSupply.low,
                    props.tokenTotalSupply.high],
                    },
                    "memeart"
                );
            } catch (error) {
                console.error("Error executing spawn:", error);
                throw error;
            }
        };
            

        return {
            world, createDrawing, colorPixels, setOwner, setPixelsRowCount, setPixelsColumnCount, setRaiseTarget, setQuoteCurrency, setTokenHash, setTokenTotalSupply
        };
    }

    return {
        MemeArt: MemeArt()
    };
}
